// @generated by protoc-gen-es v1.5.0 with parameter "target=ts"
// @generated from file eliza.proto (package connectrpc.eliza.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from message connectrpc.eliza.v1.App
 */
export class App extends Message<App> {
  /**
   * @generated from field: optional int32 id = 1;
   */
  id?: number;

  /**
   * @generated from field: optional string name = 2;
   */
  name?: string;

  /**
   * @generated from field: optional string description = 3;
   */
  description?: string;

  /**
   * @generated from field: optional string permissions = 4;
   */
  permissions?: string;

  /**
   * @generated from field: optional bool public = 5;
   */
  public?: boolean;

  /**
   * @generated from field: optional string metadata = 6;
   */
  metadata?: string;

  constructor(data?: PartialMessage<App>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.App";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "permissions", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "public", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 6, name: "metadata", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): App {
    return new App().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): App {
    return new App().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): App {
    return new App().fromJsonString(jsonString, options);
  }

  static equals(a: App | PlainMessage<App> | undefined, b: App | PlainMessage<App> | undefined): boolean {
    return proto3.util.equals(App, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.Item
 */
export class Item extends Message<Item> {
  /**
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * @generated from field: optional string image = 2;
   */
  image?: string;

  /**
   * @generated from field: optional string description = 3;
   */
  description?: string;

  /**
   * @generated from field: optional string reaction = 4;
   */
  reaction?: string;

  /**
   * @generated from field: optional bool commodity = 5;
   */
  commodity?: boolean;

  /**
   * @generated from field: optional bool tradable = 6;
   */
  tradable?: boolean;

  /**
   * @generated from field: optional bool public = 7;
   */
  public?: boolean;

  /**
   * @generated from field: optional string metadata = 8;
   */
  metadata?: string;

  constructor(data?: PartialMessage<Item>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.Item";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "image", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "reaction", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "commodity", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 6, name: "tradable", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 7, name: "public", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 8, name: "metadata", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Item {
    return new Item().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Item {
    return new Item().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Item {
    return new Item().fromJsonString(jsonString, options);
  }

  static equals(a: Item | PlainMessage<Item> | undefined, b: Item | PlainMessage<Item> | undefined): boolean {
    return proto3.util.equals(Item, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.Identity
 */
export class Identity extends Message<Identity> {
  /**
   * @generated from field: optional string slack = 1;
   */
  slack?: string;

  /**
   * @generated from field: repeated connectrpc.eliza.v1.Instance inventory = 2;
   */
  inventory: Instance[] = [];

  /**
   * @generated from field: optional string metadata = 3;
   */
  metadata?: string;

  constructor(data?: PartialMessage<Identity>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.Identity";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "slack", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "inventory", kind: "message", T: Instance, repeated: true },
    { no: 3, name: "metadata", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Identity {
    return new Identity().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Identity {
    return new Identity().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Identity {
    return new Identity().fromJsonString(jsonString, options);
  }

  static equals(a: Identity | PlainMessage<Identity> | undefined, b: Identity | PlainMessage<Identity> | undefined): boolean {
    return proto3.util.equals(Identity, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.Instance
 */
export class Instance extends Message<Instance> {
  /**
   * @generated from field: optional int32 id = 1;
   */
  id?: number;

  /**
   * @generated from field: optional string itemId = 2;
   */
  itemId?: string;

  /**
   * @generated from field: optional string identityId = 3;
   */
  identityId?: string;

  /**
   * @generated from field: optional connectrpc.eliza.v1.Item item = 4;
   */
  item?: Item;

  constructor(data?: PartialMessage<Instance>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.Instance";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "itemId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "identityId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "item", kind: "message", T: Item, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Instance {
    return new Instance().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Instance {
    return new Instance().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Instance {
    return new Instance().fromJsonString(jsonString, options);
  }

  static equals(a: Instance | PlainMessage<Instance> | undefined, b: Instance | PlainMessage<Instance> | undefined): boolean {
    return proto3.util.equals(Instance, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.Trade
 */
export class Trade extends Message<Trade> {
  /**
   * @generated from field: optional int32 id = 1;
   */
  id?: number;

  /**
   * @generated from field: optional string initiatorIdentityId = 2;
   */
  initiatorIdentityId?: string;

  /**
   * @generated from field: optional string receiverIdentityId = 3;
   */
  receiverIdentityId?: string;

  /**
   * @generated from field: repeated connectrpc.eliza.v1.Instance initiatorTrades = 4;
   */
  initiatorTrades: Instance[] = [];

  /**
   * @generated from field: repeated connectrpc.eliza.v1.Instance receiverTrades = 5;
   */
  receiverTrades: Instance[] = [];

  /**
   * @generated from field: optional bool public = 6;
   */
  public?: boolean;

  /**
   * @generated from field: optional bool closed = 7;
   */
  closed?: boolean;

  constructor(data?: PartialMessage<Trade>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.Trade";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "initiatorIdentityId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "receiverIdentityId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "initiatorTrades", kind: "message", T: Instance, repeated: true },
    { no: 5, name: "receiverTrades", kind: "message", T: Instance, repeated: true },
    { no: 6, name: "public", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 7, name: "closed", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Trade {
    return new Trade().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Trade {
    return new Trade().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Trade {
    return new Trade().fromJsonString(jsonString, options);
  }

  static equals(a: Trade | PlainMessage<Trade> | undefined, b: Trade | PlainMessage<Trade> | undefined): boolean {
    return proto3.util.equals(Trade, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.Recipe
 */
export class Recipe extends Message<Recipe> {
  /**
   * @generated from field: int32 id = 1;
   */
  id = 0;

  /**
   * @generated from field: repeated string inputsIds = 2;
   */
  inputsIds: string[] = [];

  /**
   * @generated from field: repeated string outputIds = 3;
   */
  outputIds: string[] = [];

  /**
   * @generated from field: repeated connectrpc.eliza.v1.Item inputs = 4;
   */
  inputs: Item[] = [];

  /**
   * @generated from field: repeated connectrpc.eliza.v1.Item outputs = 5;
   */
  outputs: Item[] = [];

  constructor(data?: PartialMessage<Recipe>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.Recipe";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "inputsIds", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "outputIds", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "inputs", kind: "message", T: Item, repeated: true },
    { no: 5, name: "outputs", kind: "message", T: Item, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Recipe {
    return new Recipe().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Recipe {
    return new Recipe().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Recipe {
    return new Recipe().fromJsonString(jsonString, options);
  }

  static equals(a: Recipe | PlainMessage<Recipe> | undefined, b: Recipe | PlainMessage<Recipe> | undefined): boolean {
    return proto3.util.equals(Recipe, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.CreateInstanceRequest
 */
export class CreateInstanceRequest extends Message<CreateInstanceRequest> {
  /**
   * @generated from field: int32 appId = 1;
   */
  appId = 0;

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * @generated from field: string itemId = 3;
   */
  itemId = "";

  /**
   * @generated from field: string identityId = 4;
   */
  identityId = "";

  /**
   * @generated from field: int32 quantity = 5;
   */
  quantity = 0;

  /**
   * @generated from field: optional string metadata = 6;
   */
  metadata?: string;

  /**
   * @generated from field: optional string note = 7;
   */
  note?: string;

  constructor(data?: PartialMessage<CreateInstanceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.CreateInstanceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "itemId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "identityId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "quantity", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "metadata", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "note", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInstanceRequest {
    return new CreateInstanceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInstanceRequest {
    return new CreateInstanceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInstanceRequest {
    return new CreateInstanceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateInstanceRequest | PlainMessage<CreateInstanceRequest> | undefined, b: CreateInstanceRequest | PlainMessage<CreateInstanceRequest> | undefined): boolean {
    return proto3.util.equals(CreateInstanceRequest, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.CreateInstanceResponse
 */
export class CreateInstanceResponse extends Message<CreateInstanceResponse> {
  /**
   * @generated from field: optional string response = 1;
   */
  response?: string;

  /**
   * @generated from field: optional connectrpc.eliza.v1.Instance instance = 2;
   */
  instance?: Instance;

  constructor(data?: PartialMessage<CreateInstanceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.CreateInstanceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "instance", kind: "message", T: Instance, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInstanceResponse {
    return new CreateInstanceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInstanceResponse {
    return new CreateInstanceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInstanceResponse {
    return new CreateInstanceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateInstanceResponse | PlainMessage<CreateInstanceResponse> | undefined, b: CreateInstanceResponse | PlainMessage<CreateInstanceResponse> | undefined): boolean {
    return proto3.util.equals(CreateInstanceResponse, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.CreateAppRequest
 */
export class CreateAppRequest extends Message<CreateAppRequest> {
  /**
   * @generated from field: int32 appId = 1;
   */
  appId = 0;

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * @generated from field: string name = 3;
   */
  name = "";

  /**
   * @generated from field: optional string description = 4;
   */
  description?: string;

  /**
   * @generated from field: optional int32 permissions = 5;
   */
  permissions?: number;

  /**
   * @generated from field: optional bool public = 6;
   */
  public?: boolean;

  /**
   * @generated from field: optional string metadata = 7;
   */
  metadata?: string;

  constructor(data?: PartialMessage<CreateAppRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.CreateAppRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "permissions", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 6, name: "public", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 7, name: "metadata", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateAppRequest {
    return new CreateAppRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateAppRequest {
    return new CreateAppRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateAppRequest {
    return new CreateAppRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateAppRequest | PlainMessage<CreateAppRequest> | undefined, b: CreateAppRequest | PlainMessage<CreateAppRequest> | undefined): boolean {
    return proto3.util.equals(CreateAppRequest, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.CreateAppResponse
 */
export class CreateAppResponse extends Message<CreateAppResponse> {
  /**
   * @generated from field: optional string response = 1;
   */
  response?: string;

  /**
   * @generated from field: optional connectrpc.eliza.v1.App app = 2;
   */
  app?: App;

  /**
   * @generated from field: optional string key = 3;
   */
  key?: string;

  constructor(data?: PartialMessage<CreateAppResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.CreateAppResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "app", kind: "message", T: App, opt: true },
    { no: 3, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateAppResponse {
    return new CreateAppResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateAppResponse {
    return new CreateAppResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateAppResponse {
    return new CreateAppResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateAppResponse | PlainMessage<CreateAppResponse> | undefined, b: CreateAppResponse | PlainMessage<CreateAppResponse> | undefined): boolean {
    return proto3.util.equals(CreateAppResponse, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.CreateItemRequest
 */
export class CreateItemRequest extends Message<CreateItemRequest> {
  /**
   * @generated from field: int32 appId = 1;
   */
  appId = 0;

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * @generated from field: connectrpc.eliza.v1.Item item = 3;
   */
  item?: Item;

  constructor(data?: PartialMessage<CreateItemRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.CreateItemRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "item", kind: "message", T: Item },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateItemRequest {
    return new CreateItemRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateItemRequest {
    return new CreateItemRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateItemRequest {
    return new CreateItemRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateItemRequest | PlainMessage<CreateItemRequest> | undefined, b: CreateItemRequest | PlainMessage<CreateItemRequest> | undefined): boolean {
    return proto3.util.equals(CreateItemRequest, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.CreateItemResponse
 */
export class CreateItemResponse extends Message<CreateItemResponse> {
  /**
   * @generated from field: optional string response = 1;
   */
  response?: string;

  /**
   * @generated from field: optional connectrpc.eliza.v1.Item item = 2;
   */
  item?: Item;

  constructor(data?: PartialMessage<CreateItemResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.CreateItemResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "item", kind: "message", T: Item, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateItemResponse {
    return new CreateItemResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateItemResponse {
    return new CreateItemResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateItemResponse {
    return new CreateItemResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateItemResponse | PlainMessage<CreateItemResponse> | undefined, b: CreateItemResponse | PlainMessage<CreateItemResponse> | undefined): boolean {
    return proto3.util.equals(CreateItemResponse, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.CreateRecipeRequest
 */
export class CreateRecipeRequest extends Message<CreateRecipeRequest> {
  /**
   * @generated from field: int32 appId = 1;
   */
  appId = 0;

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * @generated from field: connectrpc.eliza.v1.Recipe recipe = 3;
   */
  recipe?: Recipe;

  constructor(data?: PartialMessage<CreateRecipeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.CreateRecipeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "recipe", kind: "message", T: Recipe },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateRecipeRequest {
    return new CreateRecipeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateRecipeRequest {
    return new CreateRecipeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateRecipeRequest {
    return new CreateRecipeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateRecipeRequest | PlainMessage<CreateRecipeRequest> | undefined, b: CreateRecipeRequest | PlainMessage<CreateRecipeRequest> | undefined): boolean {
    return proto3.util.equals(CreateRecipeRequest, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.CreateRecipeResponse
 */
export class CreateRecipeResponse extends Message<CreateRecipeResponse> {
  /**
   * @generated from field: optional string response = 1;
   */
  response?: string;

  /**
   * @generated from field: optional connectrpc.eliza.v1.Recipe recipe = 2;
   */
  recipe?: Recipe;

  constructor(data?: PartialMessage<CreateRecipeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.CreateRecipeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "recipe", kind: "message", T: Recipe, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateRecipeResponse {
    return new CreateRecipeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateRecipeResponse {
    return new CreateRecipeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateRecipeResponse {
    return new CreateRecipeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateRecipeResponse | PlainMessage<CreateRecipeResponse> | undefined, b: CreateRecipeResponse | PlainMessage<CreateRecipeResponse> | undefined): boolean {
    return proto3.util.equals(CreateRecipeResponse, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.CreateTradeRequest
 */
export class CreateTradeRequest extends Message<CreateTradeRequest> {
  /**
   * @generated from field: int32 appId = 1;
   */
  appId = 0;

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * @generated from field: string initiator = 3;
   */
  initiator = "";

  /**
   * @generated from field: string receiver = 4;
   */
  receiver = "";

  /**
   * @generated from field: bool public = 5;
   */
  public = false;

  constructor(data?: PartialMessage<CreateTradeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.CreateTradeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "initiator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "receiver", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "public", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateTradeRequest {
    return new CreateTradeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateTradeRequest {
    return new CreateTradeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateTradeRequest {
    return new CreateTradeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateTradeRequest | PlainMessage<CreateTradeRequest> | undefined, b: CreateTradeRequest | PlainMessage<CreateTradeRequest> | undefined): boolean {
    return proto3.util.equals(CreateTradeRequest, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.CreateTradeResponse
 */
export class CreateTradeResponse extends Message<CreateTradeResponse> {
  /**
   * @generated from field: optional string response = 1;
   */
  response?: string;

  /**
   * @generated from field: optional connectrpc.eliza.v1.Trade trade = 2;
   */
  trade?: Trade;

  constructor(data?: PartialMessage<CreateTradeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.CreateTradeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "trade", kind: "message", T: Trade, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateTradeResponse {
    return new CreateTradeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateTradeResponse {
    return new CreateTradeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateTradeResponse {
    return new CreateTradeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateTradeResponse | PlainMessage<CreateTradeResponse> | undefined, b: CreateTradeResponse | PlainMessage<CreateTradeResponse> | undefined): boolean {
    return proto3.util.equals(CreateTradeResponse, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.ReadIdentityRequest
 */
export class ReadIdentityRequest extends Message<ReadIdentityRequest> {
  /**
   * @generated from field: int32 appId = 1;
   */
  appId = 0;

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * @generated from field: string identityId = 3;
   */
  identityId = "";

  constructor(data?: PartialMessage<ReadIdentityRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.ReadIdentityRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "identityId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadIdentityRequest {
    return new ReadIdentityRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadIdentityRequest {
    return new ReadIdentityRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadIdentityRequest {
    return new ReadIdentityRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReadIdentityRequest | PlainMessage<ReadIdentityRequest> | undefined, b: ReadIdentityRequest | PlainMessage<ReadIdentityRequest> | undefined): boolean {
    return proto3.util.equals(ReadIdentityRequest, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.ReadIdentityResponse
 */
export class ReadIdentityResponse extends Message<ReadIdentityResponse> {
  /**
   * @generated from field: optional string response = 1;
   */
  response?: string;

  /**
   * @generated from field: optional connectrpc.eliza.v1.Identity identity = 2;
   */
  identity?: Identity;

  constructor(data?: PartialMessage<ReadIdentityResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.ReadIdentityResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "identity", kind: "message", T: Identity, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadIdentityResponse {
    return new ReadIdentityResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadIdentityResponse {
    return new ReadIdentityResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadIdentityResponse {
    return new ReadIdentityResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReadIdentityResponse | PlainMessage<ReadIdentityResponse> | undefined, b: ReadIdentityResponse | PlainMessage<ReadIdentityResponse> | undefined): boolean {
    return proto3.util.equals(ReadIdentityResponse, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.ReadInventoryRequest
 */
export class ReadInventoryRequest extends Message<ReadInventoryRequest> {
  /**
   * @generated from field: int32 appId = 1;
   */
  appId = 0;

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * @generated from field: string identityId = 3;
   */
  identityId = "";

  constructor(data?: PartialMessage<ReadInventoryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.ReadInventoryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "identityId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadInventoryRequest {
    return new ReadInventoryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadInventoryRequest {
    return new ReadInventoryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadInventoryRequest {
    return new ReadInventoryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReadInventoryRequest | PlainMessage<ReadInventoryRequest> | undefined, b: ReadInventoryRequest | PlainMessage<ReadInventoryRequest> | undefined): boolean {
    return proto3.util.equals(ReadInventoryRequest, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.ReadInventoryResponse
 */
export class ReadInventoryResponse extends Message<ReadInventoryResponse> {
  /**
   * @generated from field: optional string response = 1;
   */
  response?: string;

  /**
   * @generated from field: repeated connectrpc.eliza.v1.Instance inventory = 2;
   */
  inventory: Instance[] = [];

  constructor(data?: PartialMessage<ReadInventoryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.ReadInventoryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "inventory", kind: "message", T: Instance, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadInventoryResponse {
    return new ReadInventoryResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadInventoryResponse {
    return new ReadInventoryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadInventoryResponse {
    return new ReadInventoryResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReadInventoryResponse | PlainMessage<ReadInventoryResponse> | undefined, b: ReadInventoryResponse | PlainMessage<ReadInventoryResponse> | undefined): boolean {
    return proto3.util.equals(ReadInventoryResponse, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.ReadItemRequest
 */
export class ReadItemRequest extends Message<ReadItemRequest> {
  /**
   * @generated from field: int32 appId = 1;
   */
  appId = 0;

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * @generated from field: string query = 3;
   */
  query = "";

  constructor(data?: PartialMessage<ReadItemRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.ReadItemRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadItemRequest {
    return new ReadItemRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadItemRequest {
    return new ReadItemRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadItemRequest {
    return new ReadItemRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReadItemRequest | PlainMessage<ReadItemRequest> | undefined, b: ReadItemRequest | PlainMessage<ReadItemRequest> | undefined): boolean {
    return proto3.util.equals(ReadItemRequest, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.ReadItemResponse
 */
export class ReadItemResponse extends Message<ReadItemResponse> {
  /**
   * @generated from field: optional string response = 1;
   */
  response?: string;

  /**
   * @generated from field: repeated connectrpc.eliza.v1.Item items = 2;
   */
  items: Item[] = [];

  constructor(data?: PartialMessage<ReadItemResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.ReadItemResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "items", kind: "message", T: Item, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadItemResponse {
    return new ReadItemResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadItemResponse {
    return new ReadItemResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadItemResponse {
    return new ReadItemResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReadItemResponse | PlainMessage<ReadItemResponse> | undefined, b: ReadItemResponse | PlainMessage<ReadItemResponse> | undefined): boolean {
    return proto3.util.equals(ReadItemResponse, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.ReadInstanceRequest
 */
export class ReadInstanceRequest extends Message<ReadInstanceRequest> {
  /**
   * @generated from field: int32 appId = 1;
   */
  appId = 0;

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * @generated from field: int32 instanceId = 3;
   */
  instanceId = 0;

  constructor(data?: PartialMessage<ReadInstanceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.ReadInstanceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "instanceId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadInstanceRequest {
    return new ReadInstanceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadInstanceRequest {
    return new ReadInstanceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadInstanceRequest {
    return new ReadInstanceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReadInstanceRequest | PlainMessage<ReadInstanceRequest> | undefined, b: ReadInstanceRequest | PlainMessage<ReadInstanceRequest> | undefined): boolean {
    return proto3.util.equals(ReadInstanceRequest, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.ReadInstanceResponse
 */
export class ReadInstanceResponse extends Message<ReadInstanceResponse> {
  /**
   * @generated from field: optional string response = 1;
   */
  response?: string;

  /**
   * @generated from field: optional connectrpc.eliza.v1.Instance instance = 2;
   */
  instance?: Instance;

  constructor(data?: PartialMessage<ReadInstanceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.ReadInstanceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "instance", kind: "message", T: Instance, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadInstanceResponse {
    return new ReadInstanceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadInstanceResponse {
    return new ReadInstanceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadInstanceResponse {
    return new ReadInstanceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReadInstanceResponse | PlainMessage<ReadInstanceResponse> | undefined, b: ReadInstanceResponse | PlainMessage<ReadInstanceResponse> | undefined): boolean {
    return proto3.util.equals(ReadInstanceResponse, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.ReadAppRequest
 */
export class ReadAppRequest extends Message<ReadAppRequest> {
  /**
   * @generated from field: int32 appId = 1;
   */
  appId = 0;

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * @generated from field: int32 optAppId = 3;
   */
  optAppId = 0;

  constructor(data?: PartialMessage<ReadAppRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.ReadAppRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "optAppId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadAppRequest {
    return new ReadAppRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadAppRequest {
    return new ReadAppRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadAppRequest {
    return new ReadAppRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReadAppRequest | PlainMessage<ReadAppRequest> | undefined, b: ReadAppRequest | PlainMessage<ReadAppRequest> | undefined): boolean {
    return proto3.util.equals(ReadAppRequest, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.ReadAppResponse
 */
export class ReadAppResponse extends Message<ReadAppResponse> {
  /**
   * @generated from field: optional string response = 1;
   */
  response?: string;

  /**
   * @generated from field: optional connectrpc.eliza.v1.App app = 2;
   */
  app?: App;

  constructor(data?: PartialMessage<ReadAppResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.ReadAppResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "app", kind: "message", T: App, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadAppResponse {
    return new ReadAppResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadAppResponse {
    return new ReadAppResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadAppResponse {
    return new ReadAppResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReadAppResponse | PlainMessage<ReadAppResponse> | undefined, b: ReadAppResponse | PlainMessage<ReadAppResponse> | undefined): boolean {
    return proto3.util.equals(ReadAppResponse, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.ReadTradeRequest
 */
export class ReadTradeRequest extends Message<ReadTradeRequest> {
  /**
   * @generated from field: int32 appId = 1;
   */
  appId = 0;

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * @generated from field: int32 tradeId = 3;
   */
  tradeId = 0;

  constructor(data?: PartialMessage<ReadTradeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.ReadTradeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "tradeId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadTradeRequest {
    return new ReadTradeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadTradeRequest {
    return new ReadTradeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadTradeRequest {
    return new ReadTradeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReadTradeRequest | PlainMessage<ReadTradeRequest> | undefined, b: ReadTradeRequest | PlainMessage<ReadTradeRequest> | undefined): boolean {
    return proto3.util.equals(ReadTradeRequest, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.ReadTradeResponse
 */
export class ReadTradeResponse extends Message<ReadTradeResponse> {
  /**
   * @generated from field: optional string response = 1;
   */
  response?: string;

  /**
   * @generated from field: optional connectrpc.eliza.v1.Trade trade = 2;
   */
  trade?: Trade;

  constructor(data?: PartialMessage<ReadTradeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.ReadTradeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "trade", kind: "message", T: Trade, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadTradeResponse {
    return new ReadTradeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadTradeResponse {
    return new ReadTradeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadTradeResponse {
    return new ReadTradeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReadTradeResponse | PlainMessage<ReadTradeResponse> | undefined, b: ReadTradeResponse | PlainMessage<ReadTradeResponse> | undefined): boolean {
    return proto3.util.equals(ReadTradeResponse, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.ReadRecipeRequest
 */
export class ReadRecipeRequest extends Message<ReadRecipeRequest> {
  /**
   * @generated from field: int32 appId = 1;
   */
  appId = 0;

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * @generated from field: int32 recipeId = 3;
   */
  recipeId = 0;

  constructor(data?: PartialMessage<ReadRecipeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.ReadRecipeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "recipeId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadRecipeRequest {
    return new ReadRecipeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadRecipeRequest {
    return new ReadRecipeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadRecipeRequest {
    return new ReadRecipeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReadRecipeRequest | PlainMessage<ReadRecipeRequest> | undefined, b: ReadRecipeRequest | PlainMessage<ReadRecipeRequest> | undefined): boolean {
    return proto3.util.equals(ReadRecipeRequest, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.ReadRecipeResponse
 */
export class ReadRecipeResponse extends Message<ReadRecipeResponse> {
  /**
   * @generated from field: optional string response = 1;
   */
  response?: string;

  /**
   * @generated from field: optional connectrpc.eliza.v1.Recipe recipe = 2;
   */
  recipe?: Recipe;

  constructor(data?: PartialMessage<ReadRecipeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.ReadRecipeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "recipe", kind: "message", T: Recipe, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadRecipeResponse {
    return new ReadRecipeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadRecipeResponse {
    return new ReadRecipeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadRecipeResponse {
    return new ReadRecipeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReadRecipeResponse | PlainMessage<ReadRecipeResponse> | undefined, b: ReadRecipeResponse | PlainMessage<ReadRecipeResponse> | undefined): boolean {
    return proto3.util.equals(ReadRecipeResponse, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.UpdateIdentityMetadataRequest
 */
export class UpdateIdentityMetadataRequest extends Message<UpdateIdentityMetadataRequest> {
  /**
   * @generated from field: int32 appId = 1;
   */
  appId = 0;

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * @generated from field: string identityId = 3;
   */
  identityId = "";

  /**
   * @generated from field: string metadata = 4;
   */
  metadata = "";

  constructor(data?: PartialMessage<UpdateIdentityMetadataRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.UpdateIdentityMetadataRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "identityId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "metadata", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateIdentityMetadataRequest {
    return new UpdateIdentityMetadataRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateIdentityMetadataRequest {
    return new UpdateIdentityMetadataRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateIdentityMetadataRequest {
    return new UpdateIdentityMetadataRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateIdentityMetadataRequest | PlainMessage<UpdateIdentityMetadataRequest> | undefined, b: UpdateIdentityMetadataRequest | PlainMessage<UpdateIdentityMetadataRequest> | undefined): boolean {
    return proto3.util.equals(UpdateIdentityMetadataRequest, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.UpdateIdentityMetadataResponse
 */
export class UpdateIdentityMetadataResponse extends Message<UpdateIdentityMetadataResponse> {
  /**
   * @generated from field: optional string response = 1;
   */
  response?: string;

  /**
   * @generated from field: optional connectrpc.eliza.v1.Identity identity = 2;
   */
  identity?: Identity;

  constructor(data?: PartialMessage<UpdateIdentityMetadataResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.UpdateIdentityMetadataResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "identity", kind: "message", T: Identity, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateIdentityMetadataResponse {
    return new UpdateIdentityMetadataResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateIdentityMetadataResponse {
    return new UpdateIdentityMetadataResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateIdentityMetadataResponse {
    return new UpdateIdentityMetadataResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateIdentityMetadataResponse | PlainMessage<UpdateIdentityMetadataResponse> | undefined, b: UpdateIdentityMetadataResponse | PlainMessage<UpdateIdentityMetadataResponse> | undefined): boolean {
    return proto3.util.equals(UpdateIdentityMetadataResponse, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.UpdateInstanceRequest
 */
export class UpdateInstanceRequest extends Message<UpdateInstanceRequest> {
  /**
   * @generated from field: int32 appId = 1;
   */
  appId = 0;

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * @generated from field: int32 instanceId = 3;
   */
  instanceId = 0;

  /**
   * @generated from field: connectrpc.eliza.v1.Instance new = 4;
   */
  new?: Instance;

  constructor(data?: PartialMessage<UpdateInstanceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.UpdateInstanceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "instanceId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "new", kind: "message", T: Instance },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateInstanceRequest {
    return new UpdateInstanceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateInstanceRequest {
    return new UpdateInstanceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateInstanceRequest {
    return new UpdateInstanceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateInstanceRequest | PlainMessage<UpdateInstanceRequest> | undefined, b: UpdateInstanceRequest | PlainMessage<UpdateInstanceRequest> | undefined): boolean {
    return proto3.util.equals(UpdateInstanceRequest, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.UpdateInstanceResponse
 */
export class UpdateInstanceResponse extends Message<UpdateInstanceResponse> {
  /**
   * @generated from field: optional string response = 1;
   */
  response?: string;

  /**
   * @generated from field: optional connectrpc.eliza.v1.Instance instance = 2;
   */
  instance?: Instance;

  constructor(data?: PartialMessage<UpdateInstanceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.UpdateInstanceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "instance", kind: "message", T: Instance, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateInstanceResponse {
    return new UpdateInstanceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateInstanceResponse {
    return new UpdateInstanceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateInstanceResponse {
    return new UpdateInstanceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateInstanceResponse | PlainMessage<UpdateInstanceResponse> | undefined, b: UpdateInstanceResponse | PlainMessage<UpdateInstanceResponse> | undefined): boolean {
    return proto3.util.equals(UpdateInstanceResponse, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.UpdateItemRequest
 */
export class UpdateItemRequest extends Message<UpdateItemRequest> {
  /**
   * @generated from field: int32 appId = 1;
   */
  appId = 0;

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * @generated from field: string itemId = 3;
   */
  itemId = "";

  /**
   * @generated from field: connectrpc.eliza.v1.Item new = 4;
   */
  new?: Item;

  constructor(data?: PartialMessage<UpdateItemRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.UpdateItemRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "itemId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "new", kind: "message", T: Item },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateItemRequest {
    return new UpdateItemRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateItemRequest {
    return new UpdateItemRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateItemRequest {
    return new UpdateItemRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateItemRequest | PlainMessage<UpdateItemRequest> | undefined, b: UpdateItemRequest | PlainMessage<UpdateItemRequest> | undefined): boolean {
    return proto3.util.equals(UpdateItemRequest, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.UpdateItemResponse
 */
export class UpdateItemResponse extends Message<UpdateItemResponse> {
  /**
   * @generated from field: optional string response = 1;
   */
  response?: string;

  /**
   * @generated from field: optional connectrpc.eliza.v1.Item item = 2;
   */
  item?: Item;

  constructor(data?: PartialMessage<UpdateItemResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.UpdateItemResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "item", kind: "message", T: Item, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateItemResponse {
    return new UpdateItemResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateItemResponse {
    return new UpdateItemResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateItemResponse {
    return new UpdateItemResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateItemResponse | PlainMessage<UpdateItemResponse> | undefined, b: UpdateItemResponse | PlainMessage<UpdateItemResponse> | undefined): boolean {
    return proto3.util.equals(UpdateItemResponse, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.UpdateAppRequest
 */
export class UpdateAppRequest extends Message<UpdateAppRequest> {
  /**
   * @generated from field: int32 appId = 1;
   */
  appId = 0;

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * @generated from field: optional int32 optAppId = 3;
   */
  optAppId?: number;

  /**
   * @generated from field: connectrpc.eliza.v1.App new = 4;
   */
  new?: App;

  constructor(data?: PartialMessage<UpdateAppRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.UpdateAppRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "optAppId", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: "new", kind: "message", T: App },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateAppRequest {
    return new UpdateAppRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateAppRequest {
    return new UpdateAppRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateAppRequest {
    return new UpdateAppRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateAppRequest | PlainMessage<UpdateAppRequest> | undefined, b: UpdateAppRequest | PlainMessage<UpdateAppRequest> | undefined): boolean {
    return proto3.util.equals(UpdateAppRequest, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.UpdateAppResponse
 */
export class UpdateAppResponse extends Message<UpdateAppResponse> {
  /**
   * @generated from field: optional string response = 1;
   */
  response?: string;

  /**
   * @generated from field: optional connectrpc.eliza.v1.App app = 2;
   */
  app?: App;

  constructor(data?: PartialMessage<UpdateAppResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.UpdateAppResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "app", kind: "message", T: App, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateAppResponse {
    return new UpdateAppResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateAppResponse {
    return new UpdateAppResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateAppResponse {
    return new UpdateAppResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateAppResponse | PlainMessage<UpdateAppResponse> | undefined, b: UpdateAppResponse | PlainMessage<UpdateAppResponse> | undefined): boolean {
    return proto3.util.equals(UpdateAppResponse, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.UpdateTradeRequest
 */
export class UpdateTradeRequest extends Message<UpdateTradeRequest> {
  /**
   * @generated from field: int32 appId = 1;
   */
  appId = 0;

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * @generated from field: int32 tradeId = 3;
   */
  tradeId = 0;

  /**
   * @generated from field: string identityId = 4;
   */
  identityId = "";

  /**
   * @generated from field: repeated connectrpc.eliza.v1.Instance add = 5;
   */
  add: Instance[] = [];

  constructor(data?: PartialMessage<UpdateTradeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.UpdateTradeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "tradeId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "identityId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "add", kind: "message", T: Instance, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateTradeRequest {
    return new UpdateTradeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateTradeRequest {
    return new UpdateTradeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateTradeRequest {
    return new UpdateTradeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateTradeRequest | PlainMessage<UpdateTradeRequest> | undefined, b: UpdateTradeRequest | PlainMessage<UpdateTradeRequest> | undefined): boolean {
    return proto3.util.equals(UpdateTradeRequest, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.UpdateTradeResponse
 */
export class UpdateTradeResponse extends Message<UpdateTradeResponse> {
  /**
   * @generated from field: optional string response = 1;
   */
  response?: string;

  /**
   * @generated from field: optional connectrpc.eliza.v1.Trade trade = 2;
   */
  trade?: Trade;

  constructor(data?: PartialMessage<UpdateTradeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.UpdateTradeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "trade", kind: "message", T: Trade, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateTradeResponse {
    return new UpdateTradeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateTradeResponse {
    return new UpdateTradeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateTradeResponse {
    return new UpdateTradeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateTradeResponse | PlainMessage<UpdateTradeResponse> | undefined, b: UpdateTradeResponse | PlainMessage<UpdateTradeResponse> | undefined): boolean {
    return proto3.util.equals(UpdateTradeResponse, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.UpdateRecipeRequest
 */
export class UpdateRecipeRequest extends Message<UpdateRecipeRequest> {
  /**
   * @generated from field: int32 appId = 1;
   */
  appId = 0;

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  constructor(data?: PartialMessage<UpdateRecipeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.UpdateRecipeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateRecipeRequest {
    return new UpdateRecipeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateRecipeRequest {
    return new UpdateRecipeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateRecipeRequest {
    return new UpdateRecipeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateRecipeRequest | PlainMessage<UpdateRecipeRequest> | undefined, b: UpdateRecipeRequest | PlainMessage<UpdateRecipeRequest> | undefined): boolean {
    return proto3.util.equals(UpdateRecipeRequest, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.UpdateRecipeResponse
 */
export class UpdateRecipeResponse extends Message<UpdateRecipeResponse> {
  /**
   * @generated from field: optional string response = 1;
   */
  response?: string;

  /**
   * @generated from field: optional connectrpc.eliza.v1.Recipe recipe = 2;
   */
  recipe?: Recipe;

  constructor(data?: PartialMessage<UpdateRecipeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.UpdateRecipeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "recipe", kind: "message", T: Recipe, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateRecipeResponse {
    return new UpdateRecipeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateRecipeResponse {
    return new UpdateRecipeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateRecipeResponse {
    return new UpdateRecipeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateRecipeResponse | PlainMessage<UpdateRecipeResponse> | undefined, b: UpdateRecipeResponse | PlainMessage<UpdateRecipeResponse> | undefined): boolean {
    return proto3.util.equals(UpdateRecipeResponse, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.DeleteAppRequest
 */
export class DeleteAppRequest extends Message<DeleteAppRequest> {
  /**
   * @generated from field: int32 appId = 1;
   */
  appId = 0;

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * @generated from field: int32 deleteAppId = 3;
   */
  deleteAppId = 0;

  constructor(data?: PartialMessage<DeleteAppRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.DeleteAppRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "deleteAppId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteAppRequest {
    return new DeleteAppRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteAppRequest {
    return new DeleteAppRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteAppRequest {
    return new DeleteAppRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteAppRequest | PlainMessage<DeleteAppRequest> | undefined, b: DeleteAppRequest | PlainMessage<DeleteAppRequest> | undefined): boolean {
    return proto3.util.equals(DeleteAppRequest, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.DeleteAppResponse
 */
export class DeleteAppResponse extends Message<DeleteAppResponse> {
  /**
   * @generated from field: optional string response = 1;
   */
  response?: string;

  /**
   * @generated from field: optional connectrpc.eliza.v1.App deletedApp = 2;
   */
  deletedApp?: App;

  constructor(data?: PartialMessage<DeleteAppResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.DeleteAppResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "deletedApp", kind: "message", T: App, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteAppResponse {
    return new DeleteAppResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteAppResponse {
    return new DeleteAppResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteAppResponse {
    return new DeleteAppResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteAppResponse | PlainMessage<DeleteAppResponse> | undefined, b: DeleteAppResponse | PlainMessage<DeleteAppResponse> | undefined): boolean {
    return proto3.util.equals(DeleteAppResponse, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.DeleteInstanceRequest
 */
export class DeleteInstanceRequest extends Message<DeleteInstanceRequest> {
  /**
   * @generated from field: int32 appId = 1;
   */
  appId = 0;

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * @generated from field: int32 instanceId = 3;
   */
  instanceId = 0;

  constructor(data?: PartialMessage<DeleteInstanceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.DeleteInstanceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "instanceId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteInstanceRequest {
    return new DeleteInstanceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteInstanceRequest {
    return new DeleteInstanceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteInstanceRequest {
    return new DeleteInstanceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteInstanceRequest | PlainMessage<DeleteInstanceRequest> | undefined, b: DeleteInstanceRequest | PlainMessage<DeleteInstanceRequest> | undefined): boolean {
    return proto3.util.equals(DeleteInstanceRequest, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.DeleteInstanceResponse
 */
export class DeleteInstanceResponse extends Message<DeleteInstanceResponse> {
  /**
   * @generated from field: optional string response = 1;
   */
  response?: string;

  /**
   * @generated from field: optional connectrpc.eliza.v1.Instance deletedInstance = 2;
   */
  deletedInstance?: Instance;

  constructor(data?: PartialMessage<DeleteInstanceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.DeleteInstanceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "deletedInstance", kind: "message", T: Instance, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteInstanceResponse {
    return new DeleteInstanceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteInstanceResponse {
    return new DeleteInstanceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteInstanceResponse {
    return new DeleteInstanceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteInstanceResponse | PlainMessage<DeleteInstanceResponse> | undefined, b: DeleteInstanceResponse | PlainMessage<DeleteInstanceResponse> | undefined): boolean {
    return proto3.util.equals(DeleteInstanceResponse, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.CloseTradeRequest
 */
export class CloseTradeRequest extends Message<CloseTradeRequest> {
  /**
   * @generated from field: int32 appId = 1;
   */
  appId = 0;

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * @generated from field: int32 tradeId = 3;
   */
  tradeId = 0;

  constructor(data?: PartialMessage<CloseTradeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.CloseTradeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "tradeId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CloseTradeRequest {
    return new CloseTradeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CloseTradeRequest {
    return new CloseTradeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CloseTradeRequest {
    return new CloseTradeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CloseTradeRequest | PlainMessage<CloseTradeRequest> | undefined, b: CloseTradeRequest | PlainMessage<CloseTradeRequest> | undefined): boolean {
    return proto3.util.equals(CloseTradeRequest, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.CloseTradeResponse
 */
export class CloseTradeResponse extends Message<CloseTradeResponse> {
  /**
   * @generated from field: optional string response = 1;
   */
  response?: string;

  /**
   * @generated from field: optional connectrpc.eliza.v1.Trade trade = 2;
   */
  trade?: Trade;

  constructor(data?: PartialMessage<CloseTradeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.CloseTradeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "trade", kind: "message", T: Trade, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CloseTradeResponse {
    return new CloseTradeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CloseTradeResponse {
    return new CloseTradeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CloseTradeResponse {
    return new CloseTradeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CloseTradeResponse | PlainMessage<CloseTradeResponse> | undefined, b: CloseTradeResponse | PlainMessage<CloseTradeResponse> | undefined): boolean {
    return proto3.util.equals(CloseTradeResponse, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.VerifyKeyRequest
 */
export class VerifyKeyRequest extends Message<VerifyKeyRequest> {
  /**
   * @generated from field: int32 appId = 1;
   */
  appId = 0;

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  constructor(data?: PartialMessage<VerifyKeyRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.VerifyKeyRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VerifyKeyRequest {
    return new VerifyKeyRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VerifyKeyRequest {
    return new VerifyKeyRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VerifyKeyRequest {
    return new VerifyKeyRequest().fromJsonString(jsonString, options);
  }

  static equals(a: VerifyKeyRequest | PlainMessage<VerifyKeyRequest> | undefined, b: VerifyKeyRequest | PlainMessage<VerifyKeyRequest> | undefined): boolean {
    return proto3.util.equals(VerifyKeyRequest, a, b);
  }
}

/**
 * @generated from message connectrpc.eliza.v1.VerifyKeyResponse
 */
export class VerifyKeyResponse extends Message<VerifyKeyResponse> {
  /**
   * @generated from field: bool valid = 1;
   */
  valid = false;

  constructor(data?: PartialMessage<VerifyKeyResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.eliza.v1.VerifyKeyResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "valid", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VerifyKeyResponse {
    return new VerifyKeyResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VerifyKeyResponse {
    return new VerifyKeyResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VerifyKeyResponse {
    return new VerifyKeyResponse().fromJsonString(jsonString, options);
  }

  static equals(a: VerifyKeyResponse | PlainMessage<VerifyKeyResponse> | undefined, b: VerifyKeyResponse | PlainMessage<VerifyKeyResponse> | undefined): boolean {
    return proto3.util.equals(VerifyKeyResponse, a, b);
  }
}

